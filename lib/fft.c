/*********************************************************************
Functions to perform Fast Fourier Transformations (fft).
This is part of GNU Astronomy Utilities (Gnuastro) package.

Original author:
     Alvaro Morales <alvaro96m@hotmail.com>
Contributing author(s):
Copyright (C) 2024-2024 Free Software Foundation, Inc.

Gnuastro is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.

Gnuastro is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with Gnuastro. If not, see <http://www.gnu.org/licenses/>.
**********************************************************************/
#include <config.h>

#include <error.h>
#include <string.h>

#include <gnuastro/fft.h>
#include <gnuastro/pointer.h>
#include <gnuastro/threads.h>

/**
 * @brief Struct used to pass parameters to fft_one_direction. Should be
 * initialized by fft_init and cleaned with fft_free
 */
typedef struct
{
  size_t id;
  size_t stride;
  gsl_fft_complex_wavetable *xwave;
  gsl_fft_complex_wavetable *ywave;
  gsl_fft_complex_workspace *xwork;
  gsl_fft_complex_workspace *ywork;
  size_t *indexs;
  pthread_barrier_t *b;
  gsl_const_complex_packed_array input;
  size_t *dim;
  gsl_complex_packed_array output;
  gsl_fft_direction sign;
} fft_params;

static void fft_init (fft_params **params, size_t numthreads, size_t *dim,
                      gsl_const_complex_packed_array input,
                      gsl_complex_packed_array output, gsl_fft_direction sign);
static void fft_free (fft_params *params, size_t numthreads);
static void *fft_one_direction (void *p);

/**
 * @brief Function to initialize all FFT structures needed for a 2D FFT
 *
 * @param params
 * @param numthreads
 * @param dim
 * @param input
 * @param output
 * @param sign
 */
void
fft_init (fft_params **params, size_t numthreads, size_t *dim,
          gsl_const_complex_packed_array input,
          gsl_complex_packed_array output, gsl_fft_direction sign)
{
  fft_params *buffer;
  gsl_fft_complex_wavetable *xwave;
  gsl_fft_complex_wavetable *ywave;

  /* Allocate the fft_params array. */
  errno = 0;
  buffer = malloc (numthreads * sizeof (fft_params));
  if (buffer == NULL)
    {
      error (EXIT_FAILURE, errno, "%s: allocating %zu bytes for fp", __func__,
             numthreads * sizeof (fft_params));
    }

  xwave = gsl_fft_complex_wavetable_alloc (dim[0]);
  ywave = gsl_fft_complex_wavetable_alloc (dim[1]);

  /* Write the correct parameters for each thread */
  for (size_t thread = 0; thread < numthreads; thread++)
    {
      buffer[thread].xwave = xwave;
      buffer[thread].ywave = ywave;
      buffer[thread].xwork = gsl_fft_complex_workspace_alloc (dim[0]);
      buffer[thread].ywork = gsl_fft_complex_workspace_alloc (dim[1]);
      buffer[thread].dim = dim;
      buffer[thread].input = input;
      buffer[thread].output = output;
      buffer[thread].sign = sign;
    }

  *params = buffer;
}

/**
 * @brief Clean are the resources generated by gal_fft_init
 *
 * @param params
 * @param numthreads
 */
void
fft_free (fft_params *params, size_t numthreads)
{
  gsl_fft_complex_wavetable_free (params[0].xwave);
  gsl_fft_complex_wavetable_free (params[0].ywave);

  for (size_t thread = 0; thread < numthreads; thread++)
    {
      gsl_fft_complex_workspace_free (params[thread].xwork);
      gsl_fft_complex_workspace_free (params[thread].ywork);
    }

  free (params);
}

/**
 * @brief Perform a 2D FFT
 *
 * @param input the array to apply the transformation
 * @param dim 2D array with X,Y dimensions
 * @param output
 * @param numthreads
 * @param sign Forward of backward
 */
void
gal_fft_two_dimension_transformation (gsl_const_complex_packed_array input,
                                      size_t *dim,
                                      gsl_complex_packed_array *output,
                                      size_t numthreads, size_t minmapsize,
                                      gsl_fft_direction sign)
{
  double *out; // Easier var to access than output
  fft_params *params;
  size_t size = dim[0] * dim[1];
  char *mmapname = NULL;
  size_t nb = numthreads + 1; // This running thread also counts
  pthread_t t;                /* All thread ids saved in this, not used. */
  pthread_attr_t attr;        // Used for multithread barrier
  pthread_barrier_t b;        // Used for multithread barrier
  size_t *thrds, thrdscols;

  /* Allocate the space for the output array. */
  out = gal_pointer_allocate (GAL_TYPE_COMPLEX64, size, 1, __func__, "outf");
  memcpy (out, input, size * sizeof (gsl_complex_packed_array) * 2);

  /* Init the fft needed parameters. */
  fft_init (&params, numthreads, dim, input, out, sign);

  /* 1D FFT on each row. */
  mmapname = gal_threads_dist_in_threads (dim[0], numthreads, minmapsize, 0,
                                          &thrds, &thrdscols);
  if (numthreads == 1)
    {
      params->stride = 1;
      params->indexs = thrds;
      fft_one_direction (params);
    }
  else
    {
      gal_threads_attr_barrier_init (&attr, &b, nb);
      for (size_t i = 0; i < numthreads; ++i)
        if (thrds[i * thrdscols] != GAL_BLANK_SIZE_T)
          {
            params[i].id = i;
            params[i].b = &b;
            params[i].stride = 1; /* On each row, stride=1 */
            params[i].indexs = &thrds[i * thrdscols];
            int err
                = pthread_create (&t, &attr, fft_one_direction, &params[i]);
            if (err)
              error (EXIT_FAILURE, 0, "%s: can't create thread %zu for rows",
                     __func__, i);
          }

      /* Wait for all threads to finish and free the spaces. */
      pthread_barrier_wait (&b);
      pthread_attr_destroy (&attr);
      pthread_barrier_destroy (&b);
    }

  /* Clean up. */
  if (mmapname)
    {
      gal_pointer_mmap_free (&mmapname, 0);
    }
  else
    {
      free (thrds);
    }

  /* 1D FFT on each column. */
  mmapname = gal_threads_dist_in_threads (dim[1], numthreads, minmapsize, 0,
                                          &thrds, &thrdscols);
  if (numthreads == 1)
    {
      params->stride = dim[0];
      params->indexs = thrds;
      fft_one_direction (params);
    }
  else
    {
      gal_threads_attr_barrier_init (&attr, &b, nb);
      for (size_t i = 0; i < numthreads; ++i)
        if (thrds[i * thrdscols] != GAL_BLANK_SIZE_T)
          {
            params[i].id = i;
            params[i].b = &b;
            params[i].stride = dim[0]; /* On each column, stride=X dimension */
            params[i].indexs = &thrds[i * thrdscols];
            int err
                = pthread_create (&t, &attr, fft_one_direction, &params[i]);
            if (err)
              error (EXIT_FAILURE, 0, "%s: can't create thread %zu for rows",
                     __func__, i);
          }

      /* Wait for all threads to finish and free the spaces. */
      pthread_barrier_wait (&b);
      pthread_attr_destroy (&attr);
      pthread_barrier_destroy (&b);
    }
  /* Clean up. */
  if (mmapname)
    {
      gal_pointer_mmap_free (&mmapname, 0);
    }
  else
    {
      free (thrds);
    }

  /* FFT Backward correction. */
  if (sign == gsl_fft_backward)
    {
      gal_complex_scale (out, (1.0 / (double)size), size);
    }

  /* Free FFT resources. */
  fft_free (params, numthreads);
  *output = out;
}

/**
 * @brief Performs FFT in one direction of a given amount of given
 * columns/rows. It's designed to be multithread.
 *
 * @param p
 */
void *
fft_one_direction (void *p)
{
  fft_params *params = (fft_params *)p;
  size_t lenght;
  size_t indmultip;
  size_t *indexs = params->indexs;
  gsl_fft_complex_workspace *work;
  gsl_fft_complex_wavetable *wavetable;
  gsl_complex_packed_array data;

  if (params->stride == 1) // Horizontal FFTs
    {
      lenght = params->dim[1];
      work = params->xwork;
      wavetable = params->xwave;
      indmultip = params->dim[1];
    }
  else // Vertical FFTs
    {
      lenght = params->dim[0];
      work = params->xwork;
      wavetable = params->xwave;
      indmultip = 1;
    }

  /* Calculate the FFT using the gsl implementation */
  for (size_t i = 0; indexs[i] != GAL_BLANK_SIZE_T; ++i)
    {
      data = &params->output[2 * indexs[i] * indmultip];
      gsl_fft_complex_transform (data, params->stride, lenght, wavetable, work,
                                 params->sign);
    }

  /* Wait until all other threads finish. */
  if (params->b != NULL)
    {
      pthread_barrier_wait (params->b);
    }

  return NULL;
}

/**
 * @brief Shifts along the X and Y axis to move the center to the pixel (0,0).
 * *
 * @param kernel
 * @param dim
 */
void
gal_fft_shift_center (gsl_complex_packed_array kernel, size_t *dim)
{
  gsl_complex_packed_array buffer;
  size_t xdist = dim[0] / 2;
  size_t ydist = dim[1] / 2;
  size_t size = dim[0] * dim[1];

  // Swap diagonal cuadrants for FFT
  buffer = gal_pointer_allocate (GAL_TYPE_COMPLEX64, size, 1, __func__,
                                 "shiftbuffer");
  memcpy (buffer, kernel, size * 2 * sizeof (double));

  // X-Axis shift (left)
  for (size_t x = 0; x < dim[0]; x++)
    {
      for (size_t y = 0; y < dim[1]; y++)
        {
          size_t indexkernel = (x + y * dim[0]) * 2;
          if (x <= xdist)
            {
              size_t indexbuffer = (x + xdist + y * dim[0]) * 2;
              kernel[indexkernel] = buffer[indexbuffer];
            }
          else
            {
              size_t indexbuffer = (x - xdist - 1 + y * dim[0]) * 2;
              kernel[indexkernel] = buffer[indexbuffer];
            }
        }
    }

  memcpy (buffer, kernel, size * 2 * sizeof (double));

  // Y-Axis shift (down)
  for (size_t x = 0; x < dim[0]; x++)
    {
      for (size_t y = 0; y < dim[1]; y++)
        {
          size_t indexkernel = (x + y * dim[0]) * 2;
          if (y <= ydist)
            {
              size_t indexbuffer = (x + (y + ydist) * dim[0]) * 2;
              kernel[indexkernel] = buffer[indexbuffer];
            }
          else
            {
              size_t indexbuffer = (x + (y - ydist - 1) * dim[0]) * 2;
              kernel[indexkernel] = buffer[indexbuffer];
            }
        }
    }

  // Free allocated resources
  free (buffer);
}