/*********************************************************************
Functions to perform Fast Fourier Transformations (fft).
This is part of GNU Astronomy Utilities (Gnuastro) package.

Original author:
     Alvaro Morales <alvaro96m@hotmail.com>
Contributing author(s):
Copyright (C) 2024-2024 Free Software Foundation, Inc.

Gnuastro is free software: you can redistribute it and/or modify it
under the terms of the GNU General Public License as published by the
Free Software Foundation, either version 3 of the License, or (at your
option) any later version.

Gnuastro is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with Gnuastro. If not, see <http://www.gnu.org/licenses/>.
**********************************************************************/
#include <config.h>

#include <error.h>
#include <string.h>

#include <gnuastro/fft.h>
#include <gnuastro/pointer.h>
#include <gnuastro/threads.h>

void gal_fft_init (fftparams **params, size_t numthreads, size_t *dim,
                   gsl_const_complex_packed_array input,
                   gsl_complex_packed_array output, gsl_fft_direction sign);
void gal_fft_free (fftparams *params, size_t numthreads);
void gal_fft_one_direction (void *p);

/**
 * @brief Function to initialize all FFT structures needed for a 2D FFT
 *
 * @param params
 * @param numthreads
 * @param dim
 * @param input
 * @param output
 * @param sign
 */
void
gal_fft_init (fftparams **params, size_t numthreads, size_t *dim,
              gsl_const_complex_packed_array input,
              gsl_complex_packed_array output, gsl_fft_direction sign)
{
  fftparams *buffer;
  gsl_fft_complex_wavetable *xwave;
  gsl_fft_complex_wavetable *ywave;

  /* Allocate the fftparams array. */
  errno = 0;
  buffer = malloc (numthreads * sizeof (fftparams));
  if (buffer == NULL)
    {
      error (EXIT_FAILURE, errno, "%s: allocating %zu bytes for fp", __func__,
             numthreads * sizeof (fftparams));
    }

  xwave = gsl_fft_complex_wavetable_alloc (dim[0]);
  ywave = gsl_fft_complex_wavetable_alloc (dim[1]);

  /* Write the correct parameters for each thread */
  for (size_t thread = 0; thread < numthreads; thread++)
    {
      buffer[thread].xwave = xwave;
      buffer[thread].ywave = ywave;
      buffer[thread].xwork = gsl_fft_complex_workspace_alloc (dim[0]);
      buffer[thread].ywork = gsl_fft_complex_workspace_alloc (dim[1]);
      buffer[thread].dim = dim;
      buffer[thread].input = input;
      buffer[thread].output = output;
      buffer[thread].sign = sign;
    }

  *params = buffer;
}

/**
 * @brief Clean are the resources generated by gal_fft_init
 *
 * @param params
 * @param numthreads
 */
void
gal_fft_free (fftparams *params, size_t numthreads)
{
  gsl_fft_complex_wavetable_free (params[0].xwave);
  gsl_fft_complex_wavetable_free (params[0].ywave);

  for (size_t thread = 0; thread < numthreads; thread++)
    {
      gsl_fft_complex_workspace_free (params[thread].xwork);
      gsl_fft_complex_workspace_free (params[thread].ywork);
    }

  free (params);
}

/**
 * @brief Perform a 2D FFT
 *
 * @param input the array to apply the transformation
 * @param dim 2D array with X,Y dimensions
 * @param output
 * @param numthreads
 * @param sign Forward of backward
 */
void
gal_fft_two_dimension_transformation (gsl_const_complex_packed_array input,
                                      size_t *dim,
                                      gsl_complex_packed_array *output,
                                      size_t numthreads,
                                      gsl_fft_direction sign)
{
  double *out; // Easier var to access than output
  fftparams *params;
  size_t size = dim[0] * dim[1];
  char *mmapname = NULL;
  size_t *thrds, thrdscols;

  /* Allocate the space for the output array. */
  out = gal_pointer_allocate (GAL_TYPE_COMPLEX64, size, 1, __func__, "outf");
  memcpy (out, input, size * sizeof (gsl_complex_packed_array) * 2);

  /* Init the fft needed parameters. */
  gal_fft_init (&params, numthreads, dim, input, out, sign);

  /* 1D FFT on each row. */
  mmapname = gal_threads_dist_in_threads (dim[0], numthreads, MIN_MAP_SIZE, 0,
                                          &thrds, &thrdscols);
  if (numthreads == 1)
    {
      params[0].stride = 1;
      params[0].indexs = thrds;
      gal_fft_one_direction (params);
    }
  else
    {
      // todo
    }

  /* Clean up. */
  if (mmapname)
    {
      gal_pointer_mmap_free (&mmapname, 0);
    }
  else
    {
      free (thrds);
    }

  /* 1D FFT on each column. */
  mmapname = gal_threads_dist_in_threads (dim[1], numthreads, MIN_MAP_SIZE, 0,
                                          &thrds, &thrdscols);
  if (numthreads == 1)
    {
      params[0].stride = dim[0];
      params[0].indexs = thrds;
      gal_fft_one_direction (params);
    }
  else
    {
      // todo
    }
  /* Clean up. */
  if (mmapname)
    {
      gal_pointer_mmap_free (&mmapname, 0);
    }
  else
    {
      free (thrds);
    }

  /* FFT Backward correction. */
  if (sign == gsl_fft_backward)
    {
      gal_complex_array_scale (out, (1.0 / (double)size), size);
    }

  /* Free FFT resources. */
  gal_fft_free (params, numthreads);
  *output = out;
}

/**
 * @brief Performs FFT in one direction of a given amount of given
 * columns/rows. It's designed to be multithread.
 *
 * @param p
 */
void
gal_fft_one_direction (void *p)
{
  fftparams *params = (fftparams *)p;
  size_t lenght;
  size_t indmultip;
  size_t *indexs = params->indexs;
  gsl_fft_complex_workspace *work;
  gsl_fft_complex_wavetable *wavetable;
  gsl_complex_packed_array data;

  if (params->stride == 1) // Horizontal FFTs
    {
      lenght = params->dim[1];
      work = params->xwork;
      wavetable = params->xwave;
      indmultip = params->dim[1];
    }
  else // Vertical FFTs
    {
      lenght = params->dim[0];
      work = params->xwork;
      wavetable = params->xwave;
      indmultip = 1;
    }

  /* Calculate the FFT using the gsl implementation */
  for (size_t i = 0; indexs[i] != GAL_BLANK_SIZE_T; ++i)
    {
      data = &params->output[2 * indexs[i] * indmultip];
      gsl_fft_complex_transform (data, params->stride, lenght, wavetable, work,
                                 params->sign);
    }
}

/**
 * @brief Swaps quadrants 1-3 and 2-4. Needed for kernel frequency domain
 * quadrant rearrangement (inplace)
 *
 *
 * Cuadrants:
 * 2 | 3
 * -----
 * 1 | 4
 *
 * @param kernel
 * @param size
 */
void
gal_fft_swap_quadrant (gsl_complex_packed_array kernel, size_t *dim)
{
  gsl_complex_packed_array buffer;
  size_t quadrantxsize = dim[0] / 2;
  size_t quadrantysize = dim[1] / 2;
  size_t size = dim[0] * dim[1];

  // Swap diagonal cuadrants for FFT
  buffer = gal_pointer_allocate (GAL_TYPE_COMPLEX64, size / 4, 1, __func__,
                                 "buffer");

  // 1st and 3rd quadrant swap
  for (size_t x = 0; x < quadrantxsize; x++)
    {
      for (size_t y = 0; y < quadrantysize; y++)
        {
          size_t indexb = (x * quadrantxsize + y) * 2;
          size_t index1 = (x * dim[0] + y) * 2;
          size_t index3
              = ((x + quadrantxsize) * dim[0] + y + quadrantysize) * 2;
          buffer[indexb] = kernel[index1];
          kernel[index1] = kernel[index3];
          kernel[index3] = buffer[indexb];
        }
    }

  // 2nd and 4th quadrant swap
  for (size_t x = 0; x < quadrantxsize; x++)
    {
      for (size_t y = 0; y < quadrantysize; y++)
        {
          size_t indexb = (x * quadrantxsize + y) * 2;
          size_t index2 = (x * dim[0] + y + quadrantysize) * 2;
          size_t index4 = ((x + quadrantxsize) * dim[0] + y) * 2;
          buffer[indexb] = kernel[index2];
          kernel[index2] = kernel[index4];
          kernel[index4] = buffer[indexb];
        }
    }

  // Free allocated resources
  free (buffer);
}